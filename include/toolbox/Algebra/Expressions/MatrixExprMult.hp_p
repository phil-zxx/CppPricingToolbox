#pragma once

#include <toolbox/Algebra/Typetraits/OpResultType.hpp>
#include <toolbox/Core/Error.hpp>


namespace Toolbox
{
    template <class LHS, class RHS>
    class MatrixExprMult : public Matrix<MatrixExprMult<LHS, RHS>>, Expression
    {
    public:
        using OT_LHS      = std::conditional_t<is_expression_v<LHS>, const LHS, const LHS&>;
        using OT_RHS      = std::conditional_t<is_expression_v<RHS>, const RHS, const RHS&>;
        using ElementType = OpResultType_t<OperationMul, LHS, RHS>;

        constexpr explicit MatrixExprMult(const LHS& lhs, const RHS& rhs)
            : m_lhs(lhs), m_rhs(rhs)
        {
            TB_ENSURE(lhs.colCount() == rhs.rowCount(), "Need lhs matrix column count (" << lhs.colCount() << ") to be equal to rhs matrix row count (" << rhs.rowCount() << ") when multiplying matrices");

            static_assert(is_matrix_v<LHS> && is_matrix_v<RHS>, "MatrixExprMult needs both LHS & RHS to be a matrix type");
        }

        constexpr decltype(auto) operator[](size_t i) const
        {
            const size_t rowIdx = i / this->colCount();
            const size_t colIdx = i % this->colCount();

            ElementType result = 0;
            for (size_t j = 0, size = m_lhs.colCount(); j < size; ++j)
                result += m_lhs(rowIdx, j) * m_rhs(j, colIdx);
            return result;
        }

        constexpr decltype(auto) operator()(size_t rowIdx, size_t colIdx) const
        {
            ElementType result = 0;
            for (size_t j = 0, size = m_lhs.colCount(); j < size; ++j)
                result += m_lhs(rowIdx, j) * m_rhs(j, colIdx);
            return result;
        }

        constexpr size_t size() const
        {
            return m_lhs.rowCount() * m_rhs.colCount();
        }

        constexpr MatrixShape shape() const
        {
            return MatrixShape(m_lhs.rowCount(), m_rhs.colCount());
        }

        constexpr size_t rowCount() const
        {
            return m_lhs.rowCount();
        }

        constexpr size_t colCount() const
        {
            return m_rhs.colCount();
        }

        template <class MT, class = std::enable_if_t<is_matrix_v<MT>>>
        friend void addAssign(MT& lhs, const MatrixExprMult& rhs)
        {
            OT_LHS A(rhs.m_lhs);
            OT_RHS B(rhs.m_rhs);

            const size_t rowCountL = rhs.m_lhs.rowCount();
            const size_t colCountL = rhs.m_lhs.colCount();
            const size_t rowCountR = rhs.m_rhs.rowCount();
            const size_t colCountR = rhs.m_rhs.colCount();

            for (size_t iCol = 0; iCol < colCountR; ++iCol)
            {
                for (size_t iRow = 0; iRow < rowCountL; ++iRow)
                {
                    for (size_t j = 0; j < colCountL; ++j)
                        lhs(iRow, iCol) += A(iRow, j) * B(j, iCol);
                }
            }
        }

    private:
        OT_LHS m_lhs;
        OT_RHS m_rhs;
    };

    template <class OP, class MT>
    using MatrixExprUnary = MatrixExpr<OP, MT, void*>;

    template <class OP, class MT1, class MT2>
    using MatrixExprBinary = MatrixExpr<OP, MT1, MT2>;
}
